# 变量提升

- 新版本浏览器向后兼容（ES3,ES5），向前兼容（ES6）
- 底层机制 变量作用域：当前作用域下，会把带var和function的进行提前声明或者定义
- var:只提前声明，并没有赋值
- function：提前声明，并且赋值

EC(G)
VO(G)


暂存性死区

## 数据类型
- 基础数据类型
- 引用数据类型

一般会把js放到body末尾
1. 原因：
2. 放到head是否可以？放到head中怎样实现放到body末尾的效果
3. script标签中有两个属性：defer/async，这两个属性


当浏览器加载js时，会加载一个windows的全局作用域，代码自上而下执行
var a = 12;
- 1. 先声明一个变量a，没有赋值，默认值为undefined
- 2. 在当前作用域中开辟一个位置，存储为12
- 3. 让变量a和12关联到一起（定义：赋值）
var b = a;
- 把a存储的值放到一个新的位置上（直接操作值）
- 让新位置上的值和B保持关联
- 此时b和a没有关联

值类型都是拿值操作的

var ary1 = [11, 12];
- 引用类型的值不会放到全局作用域中，会新开辟一块内存空间，并附带一个16进制的地址
- 在全局作用域中，会关联对应的16进制地址


函数也是引用数据类型
- 函数体中的内容，会以字符串的形式存入内存空间，并附带一个16进制的地址（指针）
- 在全局作用域中，会关联对应的16进制地址
- 函数执行都会行程一个私有的作用域：把之前创建函数时存储的字符串代码执行

（栈内存）
> 作用：1.提供js代码自上而下执行的环境;2.存储基本类型值
- 全局作用域
- 私有作用域

引用类型（堆内存）
> 作用：开辟内存空间，用于存储键值对或者代码字符串
- 对象
- 函数

栈内存（执行栈/作用域(全局作用域、私有作用域)）
- 1. 提供js代码自上而下执行的环境(所有js代码都是再栈中执行的)
- 2. 由于由于基本数据类型值比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存储进去的 => 当栈内存被销毁，存储的那些基本值也都跟着销毁了


堆内存（引用值对应的空间）
- 1. 存储引用类型值的（对象：键值对，函数：代码字符串）
=> 当前堆内存销毁，那么这个引用值彻底没了
=> 堆内存的释放：当堆内存没有被任何的变量或者其他东西所占用，浏览器会在空闲的时候，自主的进行内存回收，把所有不被占用的堆内存销毁掉（谷歌浏览器）
=> IE浏览器的回收机制：内存占用的计数器，计数记错了会导致内存泄漏

xxx=null 通过空对象指针，可以让原始变量(或者其他东西)谁都不指向，name与原有被占用内存就没有东西线占用了，浏览器会销毁它

内存销毁方式：
设置为null
```
ary1 = null;
ary2 = null;
sum = null;
```
