(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{384:function(t,e,a){"use strict";a.r(e);var r=a(18),i=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式原理"}},[t._v("#")]),t._v(" 响应式原理")]),t._v(" "),a("ul",[a("li",[t._v("核心"),a("code",[t._v("Object.defineProperty")])]),t._v(" "),a("li",[t._v("重新定义属性，收集依赖")]),t._v(" "),a("li",[t._v("initData(src/core/instance/state.js) => new Observer => this.walk => defineReactive => Object.defineProperty")])]),t._v(" "),a("h1",{attrs:{id:"检测数组变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检测数组变化"}},[t._v("#")]),t._v(" 检测数组变化")]),t._v(" "),a("ul",[a("li",[t._v("使用函数劫持，重写了数组的方法")]),t._v(" "),a("li",[t._v("进行原型链重写，指向了自己定义的数组原型方法，调用数组API时，可以通知依赖更新，如果数组中包含着引用类型，会对数组中定义的引用类型再次进行监控")]),t._v(" "),a("li",[t._v("initData => new Observer => protoAugment(value, arrayMethods) => 对数组的原型方法进行重写/observeArray")])]),t._v(" "),a("h1",{attrs:{id:"异步渲染原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步渲染原理"}},[t._v("#")]),t._v(" 异步渲染原理")]),t._v(" "),a("ul",[a("li",[t._v("为了性能考虑，防止一改动数据，就更新视图")]),t._v(" "),a("li",[t._v("dep.notufy() => subs[i]update() => queueWatcher => nextTick()")])]),t._v(" "),a("h1",{attrs:{id:"nexttick实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick实现原理"}},[t._v("#")]),t._v(" nextTick实现原理")]),t._v(" "),a("ul",[a("li",[t._v("只要使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列，这个nextTick方法就是异步方法")]),t._v(" "),a("li",[t._v("nextTick => callbacks => timerFunc => 返回Promise")]),t._v(" "),a("li",[t._v("timerFunc：")]),t._v(" "),a("li",[a("ol",[a("li",[t._v("尝试采用Promise回调")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("尝试采用MutationObserver回调")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[t._v("尝试采用setImmediate回调")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"4"}},[a("li",[t._v("最终采用setTimeout回调")])])])]),t._v(" "),a("h1",{attrs:{id:"computed的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed的特点"}},[t._v("#")]),t._v(" Computed的特点")]),t._v(" "),a("ul",[a("li",[t._v("计算属性有缓存")]),t._v(" "),a("li",[t._v("具备缓存")]),t._v(" "),a("li",[t._v("initComputed => new Watcher => defineComputed => createComputedGetter => 当用户取值时 =>")]),t._v(" "),a("li",[t._v("dirty=false:返回上次计算的结果")]),t._v(" "),a("li",[t._v("dirty=true:watcher：evaluate")])]),t._v(" "),a("h1",{attrs:{id:"computed、watch、method的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed、watch、method的区别"}},[t._v("#")]),t._v(" Computed、Watch、method的区别")]),t._v(" "),a("ul",[a("li",[t._v("Computed和watch的区别：内部都使用watcher")])]),t._v(" "),a("h1",{attrs:{id:"watch中的deep：true的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch中的deep：true的实现"}},[t._v("#")]),t._v(" watch中的deep：true的实现")])])}),[],!1,null,null,null);e.default=i.exports}}]);