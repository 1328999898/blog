(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{381:function(e,t,a){"use strict";a.r(t);var r=a(18),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[e._v("#")]),e._v(" React")]),e._v(" "),a("h2",{attrs:{id:"概览"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概览"}},[e._v("#")]),e._v(" 概览")]),e._v(" "),a("ul",[a("li",[e._v("React是Facebook创建的一个开源项目")]),e._v(" "),a("li",[e._v("React是一个Javascript库，不是框架")]),e._v(" "),a("li",[e._v("React是mvc模型中的view层")]),e._v(" "),a("li",[e._v("React用于构建用户界面")])]),e._v(" "),a("h2",{attrs:{id:"react应用程序的组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react应用程序的组成"}},[e._v("#")]),e._v(" React应用程序的组成")]),e._v(" "),a("ol",[a("li",[e._v("元素")]),e._v(" "),a("li",[e._v("组件")])]),e._v(" "),a("h2",{attrs:{id:"jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[e._v("#")]),e._v(" JSX")]),e._v(" "),a("p",[e._v("JSX是JavaScript中的一个语法扩展\n即"),a("code",[e._v("JavaScript")]),e._v(" + "),a("code",[e._v("XML")])]),e._v(" "),a("p",[e._v("JSX在编译时，会被babel转换为"),a("code",[e._v("React.createElement")]),e._v("方法")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" element "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("h1"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("Hello"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" world"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("h1"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("h2",{attrs:{id:"react内部的模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react内部的模块"}},[e._v("#")]),e._v(" React内部的模块")]),e._v(" "),a("p",[e._v("jsx => render => commit => DOM")]),e._v(" "),a("ol",[a("li",[e._v("render: 负责解析JSX对象，决定哪些节点最终需要渲染成DOM节点")]),e._v(" "),a("li",[e._v("commit: 把需要渲染的DOM节点渲染到页面上")])]),e._v(" "),a("h2",{attrs:{id:"schedule阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#schedule阶段"}},[e._v("#")]),e._v(" schedule阶段")]),e._v(" "),a("p",[e._v("schedule: 一种机制，处理更新的优先级，判断哪些更新应该被优先执行\njsx => schedule => render => commit => DOM")]),e._v(" "),a("ol",[a("li",[e._v("schedule: 当触发状态改变时，先判断触发的更新的优先级，然后通知render阶段接下来应该处理哪个更新")]),e._v(" "),a("li",[e._v("render: 收到schedule的通知，处理更新对应的jsx，决定哪些jsx最终是需要被渲染的")]),e._v(" "),a("li",[e._v("commit: 接收render需要被渲染的内容，渲染到页面上")])]),e._v(" "),a("h2",{attrs:{id:"commit阶段解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commit阶段解析"}},[e._v("#")]),e._v(" commit阶段解析")]),e._v(" "),a("p",[e._v("commit: 负责把需要渲染的元素渲染到页面上\n不同平台的commit：")]),e._v(" "),a("ul",[a("li",[e._v("ReactDOM: 渲染到浏览器端")]),e._v(" "),a("li",[e._v("ReactNative: 渲染APP原生组件")]),e._v(" "),a("li",[e._v("ReactTest: 渲染出纯JS对象，用于测试")]),e._v(" "),a("li",[e._v("ReactArt: 渲染到Canvas、svg或VML(IE8)")])]),e._v(" "),a("h2",{attrs:{id:"render的最小单元-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render的最小单元-fiber"}},[e._v("#")]),e._v(" render的最小单元 - Fiber")]),e._v(" "),a("p",[e._v("深度遍历")]),e._v(" "),a("h2",{attrs:{id:"react16的架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react16的架构"}},[e._v("#")]),e._v(" React16的架构")]),e._v(" "),a("ul",[a("li",[e._v("Scheduler: 调度器 --- 调度任务的优先级，高优先、")]),e._v(" "),a("li",[e._v("Reconciler: 协调器")]),e._v(" "),a("li",[e._v("Renderer: 渲染器")])]),e._v(" "),a("p",[e._v("React：没有编译时的优化手段")]),e._v(" "),a("p",[e._v("React的优化手段\n由开发者来显式的告诉React哪些组件不需要重复计算、可以复用。")]),e._v(" "),a("ul",[a("li",[e._v("使用PureComponent或React.memo构建组件")]),e._v(" "),a("li",[e._v("使用shouldComponentUpdate生命周期钩子")]),e._v(" "),a("li",[e._v("渲染列表时使用key")]),e._v(" "),a("li",[e._v("使用useCallback和useMemo缓存函数和变量")])]),e._v(" "),a("p",[e._v("响应自然\neg: 地址输入框中，输入字符时，会实时的显示地址匹配结果\n如果输入过快，可能输入会变得不那么流畅，原因：下拉列表的更新会阻塞线程\n通常是使用：debounce或throttle来减少输入内容时触发回调的次数来解决\n响应自然：考虑的是，当输入字符时，用户是否在意下拉框能在一瞬间更新？事实是不在意\n因此，可以通过稍稍延迟下拉框的更新时间，为浏览器留出时间渲染UI，使输入不卡顿\n同步更新 =》可中断的异步更新\n浏览器每一帧的时间中，预留一些时间给JS线程，React用这些时间更新组件")]),e._v(" "),a("p",[e._v("React Fiber\n内部的一套状态更新机制。支持任务不同优先级、可中断与恢复、并且恢复后，可以复用之前的中间状态\n每个任务更新单元为React Element对应的Fiber节点")]),e._v(" "),a("p",[e._v("Fiber：虚拟DOM")]),e._v(" "),a("p",[e._v("React15及以前："),a("code",[e._v("Reconciler")]),e._v("采用递归的方式创建虚拟DOM，递归过程是不能中断的，如果组件树层级很深，递归会占用很多时间，造成卡顿。\nReact16：将递归的无法中断的更新 重构为 异步的可以中断的更新，于是出现了Fiber架构")]),e._v(" "),a("p",[e._v("Fiber的三层含义")]),e._v(" "),a("ol",[a("li",[e._v("架构层面")])]),e._v(" "),a("ul",[a("li",[e._v("React15的Reconciler: 数据保存在递归调用栈中，所以称为"),a("code",[e._v("stack Reconciler")])]),e._v(" "),a("li",[e._v("React16的Reconciler: 基于Fiber实现，因此称为 "),a("code",[e._v("Fiber Reconciler")])])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("静态数据结构层面")])]),e._v(" "),a("ul",[a("li",[e._v("每个"),a("code",[e._v("Fiber节点")]),e._v("对应一个"),a("code",[e._v("React Element")]),e._v("，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息")])]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("动态工作单元")])]),e._v(" "),a("ul",[a("li",[e._v("每个"),a("code",[e._v("Fiber节点")]),e._v("保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）")])]),e._v(" "),a("p",[e._v("Fiber树\nFiber节点\nFiber节点构成的Fiber树 就对应 DOM树")])])}),[],!1,null,null,null);t.default=v.exports}}]);